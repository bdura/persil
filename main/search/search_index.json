{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Persil is a pure-python parsing library that draws much (most, let's be honest) of its inspiration from the excellent Parsy library.</p> <p>Hence the name, \"Persil\" ([p\u025b\u0281.sil] or [p\u025b\u0281.si]), the French word for parsley -a most questionable pun on <code>Parsy -&gt; Parsley -&gt; Persil</code>, in case anyone missed it.</p> <p>Like Parsy, Persil is a \"monadic parser combinator library for LL(infinity) grammars\". As a rough approximation, you can think of Persil as a typed \"fork\" of Parsy. However, although the APIs are very similar, there are notable differences that you might want to review if you're coming from Parsy.</p> <p>If you're merely looking for a somewhat type-aware version of Parsy, you may be looking for <code>parsy-stubs</code>. Mypy can use it to infer most of the types, but you'll find that shortcuts had to be taken in many cases.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>Persil is a pure-Python library. You can install it with pip:</p> <pre><code>pip install persil\n</code></pre> <p>Then, you can play with persil much the same way you would with Parsy, and enjoy the great developer experience that type-hinting brings to Persil.</p>"},{"location":"#a-basic-example","title":"A basic example","text":"<pre><code>from persil import regex\n\nyear = regex(r\"\\d{4}\").map(int)\n</code></pre> <p>This example should drive home the point that Persil is heavily inspired by Parsy. The only difference in this particular case is type-safety: the persil version knows that <code>year</code> is a parser that expects a <code>str</code>, and outputs an <code>int</code>.</p>"},{"location":"#more-complex-parsers","title":"More complex parsers","text":"<p>Parsy uses generator functions as a most elegant solution to define complex parser.</p> <p>While you can still use this approach with Persil, you're encouraged to favour the <code>from_streamer</code> decorator:</p> <pre><code>@from_streamer\ndef parser(\n    stream: Stream[str],\n) -&gt; CustomType:\n    a = stream(parser_a)\n    b = stream(parser_b)\n    c = stream(parser_c)\n\n    return CustomType(a, b, c)\n</code></pre> <p>The equivalent code, using <code>generate</code> instead (deprecated in Persil):</p> <pre><code>@generate\ndef parser() -&gt; Generator[Parser, Any, CustomType]:\n    a = yield parser_a\n    b = yield parser_b\n    c = yield parser_c\n\n    return CustomType(a, b, c)\n</code></pre> <p>The main issue with <code>generate</code> is that intermediate parsers cannot be typed, whereas <code>Stream.__call__</code> plays nice with modern Python tooling like mypy.</p>"},{"location":"#relation-with-parsy","title":"Relation with Parsy","text":"<p>First of all, I am not affiliated in any way with the Parsy project.</p>"},{"location":"#rationale","title":"Rationale","text":"<p>Parsy's last commit is from a year ago at the time of writing. Moreover, although the authors have started some development to propose a typed version of their library, efforts in that area have stalled for two years.</p>"},{"location":"#compatibility-with-parsy","title":"Compatibility with Parsy","text":"<p>Although Persil draws most of its inspiration from Parsy, maintaining a one-for-one equivalence with the latter's API is NOT among Persil's goal.</p> <p>For those coming from Parsy, here are some notable differences:</p> <ul> <li>the <code>Result</code> type is now a union between <code>Ok</code> and <code>Err</code>, which allow for a more type-safe API.</li> <li><code>Err</code> is its own error: it inherits from <code>Exception</code> and can be raised.</li> <li>Persil introduces the <code>Stream</code> class, a wrapper around the input that can apply parsers sequentially,   keeping track of the book-keeping.</li> </ul>"},{"location":"#performance-tips","title":"Performance tips","text":"<p>Since Persil takes a functional approach, every transformation on a parser produces a new parser. With that in mind, the way you define/use/combine parsers may substantially affect performance.</p> <p>Consider the following example:</p> <pre><code>from datetime import datetime\n\nfrom persil import Stream, from_stream, regex, string\n\n\n@from_stream\ndef datetime_parser(stream: Stream[str]) -&gt; datetime:\n    year = stream.apply(regex(r\"\\d{4}\").map(int))\n    stream.apply(string(\"/\"))\n    month = stream.apply(regex(r\"\\d{2}\").map(int))\n    stream.apply(string(\"/\"))\n    day = stream.apply(regex(r\"\\d{2}\").map(int))\n    return datetime(year, month, day)\n</code></pre> <p>The resulting <code>datetime_parser</code> will re-create three new regex parsers every time  it is run.</p> <p>A much better alternative:</p> <pre><code>from datetime import datetime\n\nfrom persil import Stream, from_stream, regex, string\n\n\nyear_parser = regex(r\"\\d{4}\").map(int)\nday_month_parser = regex(r\"\\d{2}\").map(int)\nslash_parser = string(\"/\")\n\n@from_stream\ndef datetime_parser(stream: Stream[str]) -&gt; datetime:\n    year = stream.apply(year_parser)\n    stream.apply(slash_parser)\n    month = stream.apply(day_month_parser)\n    stream.apply(slash_parser)\n    day = stream.apply(day_month_parser)\n    return datetime(year, month, day)\n</code></pre> <p>That way, the lower-level parsers are only defined once.</p>"},{"location":"api-reference/","title":"API Reference","text":""},{"location":"api-reference/#persil.Parser","title":"<code>Parser</code>","text":"<p>A Parser is an object that wraps a function whose arguments are a string to be parsed and the index on which to begin parsing. The function should return either <code>Result.success(next_index, value)</code>, where the next index is where to continue the parse and the value is the yielded value, or <code>Result.failure(index, expected)</code>, where expected is a string indicating what was expected, and the index is the index of the failure.</p> Source code in <code>persil/parser.py</code> <pre><code>def __init__(\n    self,\n    wrapped_fn: Callable[[Input, int], Result[Output]],\n):\n    self.wrapped_fn = wrapped_fn\n</code></pre>"},{"location":"api-reference/#persil.Parser.cut","title":"<code>cut</code>","text":"<p>Commit to the current branch by raising the error if it's returned.</p> Source code in <code>persil/parser.py</code> <pre><code>def cut(self) -&gt; \"Parser[Input, Output]\":\n    \"\"\"\n    Commit to the current branch by raising the error if it's returned.\n    \"\"\"\n\n    @Parser\n    def cut_parser(stream: Input, index: int) -&gt; Result[Output]:\n        result = self(stream, index)\n        return result.ok_or_raise()\n\n    return cut_parser\n</code></pre>"},{"location":"api-reference/#persil.Parser.then","title":"<code>then</code>","text":"<p>Returns a parser which, if the initial parser succeeds, will continue parsing with <code>other</code>. This will produce the value produced by <code>other</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>Other parser to apply if the initial parser succeeds.</p> <p> TYPE: <code>Parser[In, T]</code> </p> Source code in <code>persil/parser.py</code> <pre><code>def then(self, other: \"Parser[In, T]\") -&gt; \"Parser[Input, T]\":\n    \"\"\"\n    Returns a parser which, if the initial parser succeeds, will\n    continue parsing with `other`. This will produce the\n    value produced by `other`.\n\n    Parameters\n    ----------\n    other\n        Other parser to apply if the initial parser succeeds.\n    \"\"\"\n\n    @Parser\n    def then_parser(stream: Input, index: int) -&gt; Result[T]:\n        result = self(stream, index)\n\n        if isinstance(result, Err):\n            return result\n\n        return other(stream, result.index)  # type: ignore\n\n    return then_parser\n</code></pre>"},{"location":"api-reference/#persil.Parser.skip","title":"<code>skip</code>","text":"<p>Returns a parser which, if the initial parser succeeds, will continue parsing with <code>other</code>. It will produce the value produced by the initial parser.</p> PARAMETER  DESCRIPTION <code>other</code> <p>Other parser to apply if the initial parser succeeds.</p> <p> TYPE: <code>Parser</code> </p> Source code in <code>persil/parser.py</code> <pre><code>def skip(self, other: \"Parser\") -&gt; \"Parser[Input, Output]\":\n    \"\"\"\n    Returns a parser which, if the initial parser succeeds, will\n    continue parsing with `other`. It will produce the\n    value produced by the initial parser.\n\n    Parameters\n    ----------\n    other\n        Other parser to apply if the initial parser succeeds.\n    \"\"\"\n\n    @Parser\n    def skip_parser(stream: Input, index: int) -&gt; Result[Output]:\n        result = self(stream, index)\n\n        if isinstance(result, Err):\n            return result\n\n        other_result = other(stream, result.index)\n\n        if isinstance(other_result, Err):\n            return other_result\n\n        return result\n\n    return skip_parser\n</code></pre>"},{"location":"api-reference/#persil.Parser.combine","title":"<code>combine</code>","text":"<p>Returns a parser which, if the initial parser succeeds, will continue parsing with <code>other</code>. It will produce a tuple containing the results from both parsers, in order.</p> <p>The resulting parser fails if <code>other</code> fails.</p> PARAMETER  DESCRIPTION <code>other</code> <p>Other parser to combine.</p> <p> TYPE: <code>Parser[Input, T]</code> </p> Source code in <code>persil/parser.py</code> <pre><code>def combine(\n    self,\n    other: \"Parser[Input, T]\",\n) -&gt; \"Parser[Input, tuple[Output, T]]\":\n    \"\"\"\n    Returns a parser which, if the initial parser succeeds, will\n    continue parsing with `other`. It will produce a tuple\n    containing the results from both parsers, in order.\n\n    The resulting parser fails if `other` fails.\n\n    Parameters\n    ----------\n    other\n        Other parser to combine.\n    \"\"\"\n\n    @Parser\n    def combined_parser(stream: Input, index: int) -&gt; Result[tuple[Output, T]]:\n        res1 = self(stream, index)\n\n        if isinstance(res1, Err):\n            return res1\n\n        res2 = other(stream, res1.index)\n\n        if isinstance(res2, Err):\n            return res2\n\n        return Ok((res1.value, res2.value), res2.index)\n\n    return combined_parser\n</code></pre>"},{"location":"api-reference/#persil.Parser.parse","title":"<code>parse</code>","text":"<p>Parses a string or list of tokens and returns the result or raise a ParseError.</p> PARAMETER  DESCRIPTION <code>stream</code> <p>Input to match the parser against.</p> <p> TYPE: <code>Input</code> </p> Source code in <code>persil/parser.py</code> <pre><code>def parse(\n    self,\n    stream: Input,\n) -&gt; Output:\n    \"\"\"\n    Parses a string or list of tokens and returns the result or raise a ParseError.\n\n    Parameters\n    ----------\n    stream\n        Input to match the parser against.\n    \"\"\"\n    (result, _) = (self &lt;&lt; eof).parse_partial(stream)\n    return result\n</code></pre>"},{"location":"api-reference/#persil.Parser.parse_partial","title":"<code>parse_partial</code>","text":"<p>Parses the longest possible prefix of a given string. Returns a tuple of the result and the unparsed remainder, or raises <code>ParseError</code>.</p> PARAMETER  DESCRIPTION <code>stream</code> <p>Input to match the parser against.</p> <p> TYPE: <code>Input</code> </p> Source code in <code>persil/parser.py</code> <pre><code>def parse_partial(\n    self,\n    stream: Input,\n) -&gt; tuple[Output, Input]:\n    \"\"\"\n    Parses the longest possible prefix of a given string.\n    Returns a tuple of the result and the unparsed remainder,\n    or raises `ParseError`.\n\n    Parameters\n    ----------\n    stream\n        Input to match the parser against.\n    \"\"\"\n\n    result = self(stream, 0)\n\n    if isinstance(result, Err):\n        raise result\n\n    value = result.value\n    remainder = cast(Input, stream[result.index :])\n\n    return (value, remainder)\n</code></pre>"},{"location":"api-reference/#persil.Parser.map","title":"<code>map</code>","text":"<p>Returns a parser that transforms the produced value of the initial parser with <code>map_function</code>.</p> Source code in <code>persil/parser.py</code> <pre><code>def map(\n    self,\n    map_function: Callable[[Output], T],\n) -&gt; \"Parser[Input, T]\":\n    \"\"\"\n    Returns a parser that transforms the produced value of the initial parser\n    with `map_function`.\n    \"\"\"\n\n    @Parser\n    def mapped_parser(stream: Input, index: int) -&gt; Result[T]:\n        res = self(stream, index)\n        return res.map(map_function)\n\n    return mapped_parser\n</code></pre>"},{"location":"api-reference/#persil.Parser.result","title":"<code>result</code>","text":"<p>Returns a parser that, if the initial parser succeeds, always produces the passed in <code>value</code>.</p> Source code in <code>persil/parser.py</code> <pre><code>def result(self, value: T) -&gt; \"Parser[Input, T]\":\n    \"\"\"\n    Returns a parser that, if the initial parser succeeds, always produces\n    the passed in `value`.\n    \"\"\"\n\n    @Parser\n    def result_parser(stream: Input, index: int) -&gt; Result[T]:\n        res = self(stream, index)\n\n        if isinstance(res, Err):\n            return res\n\n        return Ok(value, res.index)\n\n    return result_parser\n</code></pre>"},{"location":"api-reference/#persil.Parser.times","title":"<code>times</code>","text":"<p>Returns a parser that expects the initial parser at least <code>min</code> times, and at most <code>max</code> times, and produces a list of the results. If only one argument is given, the parser is expected exactly that number of times.</p> PARAMETER  DESCRIPTION <code>min</code> <p>Minimal number of times the parser should match.</p> <p> TYPE: <code>int</code> </p> <code>max</code> <p>Maximal number of times the parser should match. Equals to <code>min</code> by default</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> Source code in <code>persil/parser.py</code> <pre><code>def times(\n    self,\n    min: int,\n    max: int | None = None,\n) -&gt; \"Parser[Input, list[Output]]\":\n    \"\"\"\n    Returns a parser that expects the initial parser at least `min` times,\n    and at most `max` times, and produces a list of the results. If only one\n    argument is given, the parser is expected exactly that number of times.\n\n    Parameters\n    ----------\n    min\n        Minimal number of times the parser should match.\n    max\n        Maximal number of times the parser should match.\n        Equals to `min` by default\n    \"\"\"\n    if max is None:\n        max = min\n\n    @Parser\n    def times_parser(stream: Input, index: int) -&gt; Result[list[Output]]:\n        values = []\n        times = 0\n        result = None\n\n        while times &lt; max:\n            result = self(stream, index)\n            if isinstance(result, Ok):\n                values.append(result.value)\n                index = result.index\n                times += 1\n            elif times &gt;= min:\n                break\n            else:\n                return result\n\n        return Ok(values, index)\n\n    return times_parser\n</code></pre>"},{"location":"api-reference/#persil.Parser.many","title":"<code>many</code>","text":"<p>Returns a parser that expects the initial parser 0 or more times, and produces a list of the results.</p> Source code in <code>persil/parser.py</code> <pre><code>def many(self) -&gt; \"Parser[Input, list[Output]]\":\n    \"\"\"\n    Returns a parser that expects the initial parser 0 or more times, and\n    produces a list of the results.\n    \"\"\"\n    return self.times(0, 9999999)\n</code></pre>"},{"location":"api-reference/#persil.Parser.at_most","title":"<code>at_most</code>","text":"<p>Returns a parser that expects the initial parser at most <code>n</code> times, and produces a list of the results.</p> PARAMETER  DESCRIPTION <code>n</code> <p>Maximum number of times the parser should match.</p> <p> TYPE: <code>int</code> </p> Source code in <code>persil/parser.py</code> <pre><code>def at_most(self, n: int) -&gt; \"Parser[Input, list[Output]]\":\n    \"\"\"\n    Returns a parser that expects the initial parser at most `n` times, and\n    produces a list of the results.\n\n    Parameters\n    ----------\n    n\n        Maximum number of times the parser should match.\n    \"\"\"\n    return self.times(0, n)\n</code></pre>"},{"location":"api-reference/#persil.Parser.at_least","title":"<code>at_least</code>","text":"<p>Returns a parser that expects the initial parser at least <code>n</code> times, and produces a list of the results.</p> PARAMETER  DESCRIPTION <code>n</code> <p>Minimum number of times the parser should match.</p> <p> TYPE: <code>int</code> </p> Source code in <code>persil/parser.py</code> <pre><code>def at_least(self, n: int) -&gt; \"Parser[Input, list[Output]]\":\n    \"\"\"\n    Returns a parser that expects the initial parser at least `n` times, and\n    produces a list of the results.\n\n    Parameters\n    ----------\n    n\n        Minimum number of times the parser should match.\n    \"\"\"\n    return self.times(n) + self.many()\n</code></pre>"},{"location":"api-reference/#persil.Parser.optional","title":"<code>optional</code>","text":"<p>Returns a parser that expects the initial parser zero or once, and maps the result to a given default value in the case of no match. If no default value is given, <code>None</code> is used.</p> PARAMETER  DESCRIPTION <code>default</code> <p>Default value to output.</p> <p> TYPE: <code>T | None</code> DEFAULT: <code>None</code> </p> Source code in <code>persil/parser.py</code> <pre><code>def optional(self, default: T | None = None) -&gt; \"Parser[Input, Output | T | None]\":\n    \"\"\"\n    Returns a parser that expects the initial parser zero or once, and maps\n    the result to a given default value in the case of no match. If no default\n    value is given, `None` is used.\n\n    Parameters\n    ----------\n    default\n        Default value to output.\n    \"\"\"\n\n    @Parser\n    def optional_parser(stream: Input, index: int) -&gt; Result[Output | T | None]:\n        res = self(stream, index)\n\n        if isinstance(res, Ok):\n            return Ok(res.value, res.index)\n\n        return Ok(default, index)\n\n    return optional_parser\n</code></pre>"},{"location":"api-reference/#persil.Parser.until","title":"<code>until</code>","text":"<p>Returns a parser that expects the initial parser followed by <code>other</code>. The initial parser is expected at least <code>min</code> times and at most <code>max</code> times.</p> <p>The new parser consumes <code>other</code> and returns it as part of an output tuple. If you are looking for a non-consuming parser, checkout <code>until_and_discard</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>Other parser to check.</p> <p> TYPE: <code>Parser[Input, T]</code> </p> <code>min</code> <p>Minimum number of times that the initial parser should match before matching <code>other</code></p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max</code> <p>Maximum number of times that the initial parser should match before matching <code>other</code></p> <p> TYPE: <code>int</code> DEFAULT: <code>999999</code> </p> Source code in <code>persil/parser.py</code> <pre><code>def until(\n    self,\n    other: \"Parser[Input, T]\",\n    min: int = 0,\n    max: int = 999999,\n) -&gt; \"Parser[Input, tuple[list[Output], T]]\":\n    \"\"\"\n    Returns a parser that expects the initial parser followed by `other`.\n    The initial parser is expected at least `min` times and at most `max` times.\n\n    The new parser consumes `other` and returns it as part of an output tuple.\n    If you are looking for a non-consuming parser, checkout `until_and_discard`.\n\n    Parameters\n    ----------\n    other\n        Other parser to check.\n    min\n        Minimum number of times that the initial parser should match before\n        matching `other`\n    max\n        Maximum number of times that the initial parser should match before\n        matching `other`\n    \"\"\"\n\n    @Parser\n    def until_parser(stream: Input, index: int) -&gt; Result[tuple[list[Output], T]]:\n        values: list[Output] = []\n        times = 0\n\n        while True:\n            # try parser first\n            res = other(stream, index)\n\n            if isinstance(res, Ok) and times &gt;= min:\n                return Ok((values, res.value), index)\n\n            # exceeded max?\n            if isinstance(res, Ok) and times &gt;= max:\n                # return failure, it matched parser more than max times\n                return Err(index, [f\"at most {max} items\"], stream)\n\n            # failed, try parser\n            result = self(stream, index)\n\n            if isinstance(result, Ok):\n                values.append(result.value)\n                index = result.index\n                times += 1\n                continue\n\n            if times &gt;= min:\n                # return failure, parser is not followed by other\n                return Err(index, [\"did not find other parser\"], stream)\n            else:\n                # return failure, it did not match parser at least min times\n                return Err(\n                    index,\n                    [f\"at least {min} items; got {times} item(s)\"],\n                    stream,\n                )\n\n    return until_parser\n</code></pre>"},{"location":"api-reference/#persil.Parser.until_and_discard","title":"<code>until_and_discard</code>","text":"<p>Returns a parser that expects the initial parser followed by <code>other</code>. The initial parser is expected at least <code>min</code> times and at most <code>max</code> times.</p> <p>Does not consume <code>other</code>. If you are looking for that behaviour, checkout <code>until</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>Other parser to check.</p> <p> TYPE: <code>Parser[Input, T]</code> </p> <code>min</code> <p>Minimum number of times that the initial parser should match before matching <code>other</code>.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max</code> <p>Maximum number of times that the initial parser should match before matching <code>other</code>.</p> <p> TYPE: <code>int</code> DEFAULT: <code>999999</code> </p> Source code in <code>persil/parser.py</code> <pre><code>def until_and_discard(\n    self,\n    other: \"Parser[Input, T]\",\n    min: int = 0,\n    max: int = 999999,\n) -&gt; \"Parser[Input, list[Output]]\":\n    \"\"\"\n    Returns a parser that expects the initial parser followed by `other`.\n    The initial parser is expected at least `min` times and at most `max` times.\n\n    Does not consume `other`. If you are looking for that behaviour,\n    checkout `until`.\n\n    Parameters\n    ----------\n    other\n        Other parser to check.\n    min\n        Minimum number of times that the initial parser should match before\n        matching `other`.\n    max\n        Maximum number of times that the initial parser should match before\n        matching `other`.\n    \"\"\"\n\n    def discard_next_value(output: tuple[list[Output], T]) -&gt; list[Output]:\n        values, _ = output\n        return values\n\n    return self.until(other, min=min, max=max).map(discard_next_value)\n</code></pre>"},{"location":"api-reference/#persil.Parser.sep_by","title":"<code>sep_by</code>","text":"<p>Returns a new parser that repeats the initial parser and collects the results in a list. Between each item, the <code>sep</code> parser is run (and its return value is discarded). By default it repeats with no limit, but minimum and maximum values can be supplied.</p> PARAMETER  DESCRIPTION <code>sep</code> <p>Parser that separates values.</p> <p> TYPE: <code>Parser</code> </p> <code>min</code> <p>Minimum number of times that the initial parser should match.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>max</code> <p>Maximum number of times that the initial parser should match.</p> <p> TYPE: <code>int</code> DEFAULT: <code>999999</code> </p> Source code in <code>persil/parser.py</code> <pre><code>def sep_by(\n    self,\n    sep: \"Parser\",\n    *,\n    min: int = 0,\n    max: int = 999999,\n) -&gt; \"Parser[Input, list[Output]]\":\n    \"\"\"\n    Returns a new parser that repeats the initial parser and\n    collects the results in a list. Between each item, the `sep` parser\n    is run (and its return value is discarded). By default it\n    repeats with no limit, but minimum and maximum values can be supplied.\n\n    Parameters\n    ----------\n    sep\n        Parser that separates values.\n    min\n        Minimum number of times that the initial parser should match.\n    max\n        Maximum number of times that the initial parser should match.\n    \"\"\"\n    zero_times: Parser[Input, list[Output]] = success([])\n\n    if max == 0:\n        return zero_times\n    res = self.times(1) + (sep &gt;&gt; self).times(min - 1, max - 1)\n    if min == 0:\n        res |= zero_times\n    return res\n</code></pre>"},{"location":"api-reference/#persil.Parser.desc","title":"<code>desc</code>","text":"<p>Returns a new parser with a description added, which is used in the error message if parsing fails.</p> PARAMETER  DESCRIPTION <code>description</code> <p>Description in case of failure.</p> <p> TYPE: <code>str</code> </p> Source code in <code>persil/parser.py</code> <pre><code>def desc(\n    self,\n    description: str,\n) -&gt; \"Parser[Input, Output]\":\n    \"\"\"\n    Returns a new parser with a description added, which is used in the error message\n    if parsing fails.\n\n    Parameters\n    ----------\n    description\n        Description in case of failure.\n    \"\"\"\n\n    @Parser\n    def desc_parser(stream: Input, index: int) -&gt; Result[Output]:\n        result = self(stream, index)\n        if isinstance(result, Ok):\n            return result\n        return Err(index, [description], stream)\n\n    return desc_parser\n</code></pre>"},{"location":"api-reference/#persil.Parser.should_fail","title":"<code>should_fail</code>","text":"<p>Returns a parser that fails when the initial parser succeeds, and succeeds when the initial parser fails (consuming no input). A description must be passed which is used in parse failure messages.</p> <p>This is essentially a negative lookahead.</p> PARAMETER  DESCRIPTION <code>description</code> <p>Description in case of failure.</p> <p> TYPE: <code>str</code> </p> Source code in <code>persil/parser.py</code> <pre><code>def should_fail(\n    self,\n    description: str,\n) -&gt; \"Parser[Input, Result[Output]]\":\n    \"\"\"\n    Returns a parser that fails when the initial parser succeeds, and succeeds\n    when the initial parser fails (consuming no input). A description must\n    be passed which is used in parse failure messages.\n\n    This is essentially a negative lookahead.\n\n    Parameters\n    ----------\n    description\n        Description in case of failure.\n    \"\"\"\n\n    @Parser\n    def fail_parser(stream: Input, index: int):\n        res = self(stream, index)\n        if isinstance(res, Ok):\n            return Err(index, [description], stream)\n        return Ok(res, index)\n\n    return fail_parser\n</code></pre>"},{"location":"api-reference/#persil.Stream","title":"<code>Stream</code>","text":"<p>The <code>Stream</code> API lets you apply parsers iteratively, and handles the index bookeeping for you. Its design goal is to be used with the <code>from_stream</code> decorator.</p> Source code in <code>persil/stream.py</code> <pre><code>def __init__(self, inner: In, index: int = 0):\n    self.inner = inner\n    self.index = index\n</code></pre>"},{"location":"api-reference/#persil.generate","title":"<code>generate</code>","text":"<p>Create a complex parser using the generator syntax.</p> <p>You should prefer the <code>from_stream</code> syntax, which is an alternative that plays better with types.</p> Source code in <code>persil/generator.py</code> <pre><code>def generate(gen):\n    \"\"\"\n    Create a complex parser using the generator syntax.\n\n    You should prefer the `from_stream` syntax, which is an alternative that\n    plays better with types.\n    \"\"\"\n    if isinstance(gen, str):\n        return lambda f: _generate(f).desc(gen)\n\n    else:\n        return _generate(gen)\n</code></pre>"},{"location":"api-reference/#persil.success","title":"<code>success</code>","text":"<p>Returns a parser that does not consume any of the stream, but produces <code>value</code>.</p> PARAMETER  DESCRIPTION <code>description</code> <p>Description in case of failure.</p> <p> </p> Source code in <code>persil/parser.py</code> <pre><code>def success(\n    value: T,\n) -&gt; Parser[Input, T]:\n    \"\"\"\n    Returns a parser that does not consume any of the stream, but\n    produces `value`.\n\n    Parameters\n    ----------\n    description\n        Description in case of failure.\n    \"\"\"\n    return Parser(lambda _, index: Ok(value, index))\n</code></pre>"},{"location":"api-reference/#persil.fail","title":"<code>fail</code>","text":"<p>Returns a parser that always fails with the provided error message.</p> Source code in <code>persil/parsers/outcome.py</code> <pre><code>def fail(expected: str) -&gt; Parser:\n    \"\"\"\n    Returns a parser that always fails with the provided error message.\n    \"\"\"\n\n    @Parser\n    def fail_parser(stream: Sequence, index: int) -&gt; Result:\n        return Err(index, [expected], stream)\n\n    return fail_parser\n</code></pre>"},{"location":"api-reference/#persil.line_info","title":"<code>line_info</code>","text":"<p>Return the line information (row, col)</p> Source code in <code>persil/parsers/index.py</code> <pre><code>@Parser\ndef line_info(stream: S, index: int) -&gt; Result[RowCol]:\n    \"\"\"Return the line information (row, col)\"\"\"\n    return Ok(line_info_at(stream, index), index)\n</code></pre>"},{"location":"api-reference/#persil.regex_groupdict","title":"<code>regex_groupdict</code>","text":"<p>Returns a parser that leverages named groups to obtain the return value.</p> <p>For instance, the following pattern: (eg <code>(?P&lt;year&gt;\\d{4})-(?P&lt;month&gt;\\d{2})</code>) will return a dictionary with two keys, <code>year</code> and <code>month</code>.</p> Source code in <code>persil/parsers/regex.py</code> <pre><code>def regex_groupdict(\n    exp: str | re.Pattern[str],\n    flags=0,\n) -&gt; Parser[str, dict[str, str | None]]:\n    \"\"\"\n    Returns a parser that leverages named groups to obtain the return value.\n\n    For instance, the following pattern: (eg `(?P&lt;year&gt;\\d{4})-(?P&lt;month&gt;\\d{2})`)\n    will return a dictionary with two keys, `year` and `month`.\n    \"\"\"\n    if isinstance(exp, (str, bytes)):\n        exp = re.compile(exp, flags)\n\n    @Parser\n    def regex_groupdict_parser(\n        stream: str,\n        index: int,\n    ) -&gt; Result[dict[str, str | None]]:\n        match = exp.match(stream, index)\n        if match:\n            return Ok(match.groupdict(), match.end())\n        else:\n            return Err(index, [exp.pattern], stream)\n\n    return regex_groupdict_parser\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""}]}